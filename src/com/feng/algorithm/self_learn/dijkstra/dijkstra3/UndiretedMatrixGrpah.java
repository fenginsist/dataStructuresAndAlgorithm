package com.feng.algorithm.self_learn.dijkstra.dijkstra3;

import java.util.*;


/**
 * 
 * @author chp
 *
 * @param <V>
 * 
 * 无向邻接矩阵图
 */

public class UndiretedMatrixGrpah<V> implements Graph<V> {
	private List<V> vertexList; // ?????????
	private int[][] edgeMatrix; // ??????????
	private int edges; // ???????
	private int vertices; // ????????
	private int size; // ???

	public UndiretedMatrixGrpah(int size) {
		this.size = size;
		vertexList = new ArrayList<>();
		edgeMatrix = new int[size][size];
		this.edges = 0;
		this.vertices = 0;
	}

	@Override
	public int edgesSize() {
		// TODO Auto-generated method stub
		return this.edges;
	}

	@Override
	public int verticesSize() {
		// TODO Auto-generated method stub
		return this.vertices;
	}

	@Override
	public void addVertex(V v) {
		// ???????????
		this.vertexList.add(v);
		this.vertices++;
	}

	@Override
	public void addEdge(V from, V to) {
		// TODO Auto-generated method stub
		this.addEdge(from, to, 1);
	}

	@Override
	public void addEdge(V from, V to, int weight) {
		// TODO Auto-generated method stub
		int i = this.vertexList.indexOf(from);
		int j = this.vertexList.indexOf(to);
		this.edgeMatrix[i][j] = weight;
		this.edgeMatrix[j][i] = weight;
		this.edges++;

	}

	@Override
	public void removeEdge(V from, V to) {
		// ????????
		int i = this.vertexList.indexOf(from);
		int j = this.vertexList.indexOf(to);
		this.edgeMatrix[i][j] = 0;
		this.edgeMatrix[j][i] = 0;
		this.edges--;
	}

	@Override
	public void removeVertex(V v) {
		// ??????????
		int index = this.vertexList.indexOf(v); // ?????????????

		for (int i = 0; i < this.vertices; i++) {
			if (this.edgeMatrix[index][i] != 0) { // ???index??i??????????
				this.edges--;
			}
		}

		// index?????????????????
		for (int i = index; i < this.vertices - 1; i++) {
			for (int j = 0; j < this.vertices; j++) {
				this.edgeMatrix[i][j] = this.edgeMatrix[i + 1][j];
			}
		}

		// index?????????????????
		for (int i = 0; i < this.vertices; i++) {
			for (int j = index; j < this.vertices - 1; j++) {
				this.edgeMatrix[i][j] = this.edgeMatrix[i][j + 1];
			}
		}

		this.vertexList.remove(index);
		this.vertices--;

	}

	@Override
	public void displayGraph() {
		// ???????
		System.out.println("?????????????????????");
		System.out.println("????" + this.vertexList);
		System.out.println("????????????");
		for (int i = 0; i < this.vertices; i++) {
			for (int j = 0; j < this.vertices; j++) {
				System.out.print(this.edgeMatrix[i][j] + " ");
			}
			System.out.println();
		}
	}

	@Override
	public int degree(V v) {
		// ??????????v???

		int index = this.vertexList.indexOf(v); // ???????????
		int count = 0;
		for (int i = 0; i < this.vertices; i++) {
			if (this.edgeMatrix[index][i] != 0) { // ???index??i??????????
				count++;
			}
		}
		return count;
	}

	@Override
	public void dfs() {
		// ??????????
		boolean[] beTraversed = new boolean[this.vertices];
		// ??????????????????false
		beTraversed[0] = true;
		System.out.print("???????????????");
		System.out.print(this.vertexList.get(0));
		this.dfs(0, 1, beTraversed);
		System.out.println();

	}

	private void dfs(int x, int y, boolean[] beTraversed) {
		// ????x???y??????
		while (y < this.vertices) {
			if (this.edgeMatrix[x][y] != 0 && !beTraversed[y]) {
				beTraversed[y] = true;
				System.out.print(this.vertexList.get(y));
				this.dfs(y, 0, beTraversed); // ??y???0?????????????????
			}
			y++;
		}

	}

	@Override
	public void bfs() {
		// ??????????
		boolean[] beTraversed = new boolean[this.vertices];
		// ??????????????????false
		beTraversed[0] = true;
		Queue<Integer> queue = new LinkedList<>();
		beTraversed[0] = true;
		queue.offer(0);

		System.out.print("????????????");
		while (!queue.isEmpty()) {
			int index = queue.poll();
			System.out.print(this.vertexList.get(index));
			for (int i = 0; i < this.vertices; i++) {
				if (this.edgeMatrix[index][i] != 0 && !beTraversed[i]) {
					// ????????????????????
					beTraversed[i] = true;
					queue.offer(i);
				}
			}
		}
		System.out.println();

	}

	/*
	 * ???prim???????????????
	 */
	public void prim() {
		ArrayList<Integer> listU = new ArrayList<>(); // ??????????????????
		listU.add(0);
		ArrayList<Integer> listV = new ArrayList<>(); // ??????????????????????
		for (int i = 1; i < this.vertices; i++) {
			listV.add(i);
		}
		int miniWeight;
		int miniFrom = -1;
		int miniTo = -1;
		while (!listV.isEmpty()) {
			// ????????????????????????
			miniWeight = Integer.MAX_VALUE; // ???????????????????????????????????????
			for (int i : listU) {
				for (int j : listV) {
					if (this.edgeMatrix[i][j] != 0 && this.edgeMatrix[i][j] < miniWeight) {
						miniWeight = this.edgeMatrix[i][j];
						miniFrom = i;
						miniTo = j;
					}
				}
			}
			listU.add(miniTo);
			listV.remove(new Integer(miniTo));

			System.out.println("Edge: <" + this.vertexList.get(miniFrom) + ", " + this.vertexList.get(miniTo) + "> : "
					+ miniWeight);

		}
	}
	/**
	 * 	???????
	 */
	class Edge<V>{
		V from;			//???????
		V to ;			//????????
		int weigth;	//?????
		public Edge(V from, V to, int weigth) {
			super();
			this.from = from;
			this.to = to;
			this.weigth = weigth;
		}
		@Override
		public String toString() {
			return "Edge [from=" + from + ", to=" + to + ", weigth=" + weigth + "]";
		}
		
	}
	
	public void kruskal(){
		ArrayList<Edge> edgelist = new ArrayList<>(); //?????
		int[] list = new int[this.vertices];		//list[i]?????????i??????????????????????????
		int count = 0 ;			//????????????????
		for(int i = 0;i<this.vertices;i++) {
			for(int  j = i+1 ; j<this.vertices;j++) {
				if(this.edgeMatrix[i][j] != 0) {
					edgelist.add( new Edge<V>(this.vertexList.get(i), this.vertexList.get(j), this.edgeMatrix[i][j]));
				}
			}
		}
		Collections.sort(edgelist, new Comparator<Edge>() {

			@Override
			public int compare(Edge o1, Edge o2) {
				// TODO Auto-generated method stub
				return o1.weigth - o2.weigth;
			}
		});
		System.out.println(edgelist);

		System.out.println("????????????");

		for(Edge edge:edgelist) {					//???????????????
			int from = this.vertexList.indexOf(edge.from);   //?????????????
			int to = this.vertexList.indexOf(edge.to);		//?????????????

			int  m = this.getEnd(from,list);		//????????????????????????????????
			int  n = this.getEnd(to,list);			//????????????????????????????????

			if(m != n) {				//????????????????????
				list[m] = n;			//????????????????????????????????????
				System.out.println(edge);
				count++;
				if(count == this.vertices-1) {
					break;
				}
			}

		}
	}

	private int getEnd(int x,int[] list) {
		while(list[x] != 0) {
			x = list[x];
		}
		
		return x;
	}
	
}
